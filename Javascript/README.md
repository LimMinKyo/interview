# Javascript

## var와 let, const의 차이점은 무엇인가요?

`var`, `let`, 그리고 `const`는 JavaScript에서 변수를 선언하는 키워드입니다. 이들의 주요 차이점은 다음과 같습니다:

1. **Scope(범위)**:

   - `var`: 함수 스코프를 갖습니다. 함수 내에서 선언된 변수는 함수 내부에서만 유효합니다.
   - `let`과 `const`: 블록 스코프를 갖습니다. 블록 내에서 선언된 변수는 해당 블록 내부에서만 유효합니다. 블록은 중괄호 `{}`로 정의되는 영역입니다.

2. **Hoisting(호이스팅)**:

   - `var`: 선언이 함수나 전역 스코프의 맨 위로 끌어올려집니다. 그러므로 변수가 선언되기 이전에 참조해도 에러가 발생하지 않습니다. 하지만 초기화는 호이스팅되지 않습니다.
   - `let`과 `const`: 호이스팅은 발생하지만, TDZ(Temporal Dead Zone)라는 구역에서 변수에 접근하려고 할 때 초기화 전에는 에러가 발생합니다.

3. **재할당 가능 여부**:

   - `var`와 `let`: 재할당이 가능합니다.
   - `const`: 한 번 할당하면 재할당할 수 없습니다. 상수로 취급되어 재할당하려고 하면 에러가 발생합니다. 하지만 const로 선언된 객체나 배열의 속성은 변경할 수 있습니다.

4. **전역 객체와의 관계**:

   - `var`로 선언한 변수는 전역 객체의 프로퍼티가 됩니다. 즉, 브라우저 환경에서는 `window` 객체의 프로퍼티가 됩니다.
   - `let`과 `const`로 선언한 변수는 전역 객체의 프로퍼티가 되지 않습니다. 이는 변수가 선언된 블록 내에서만 유효하기 때문입니다.

일반적으로는 `let`과 `const`를 사용하여 변수를 선언하는 것이 권장됩니다. 이는 스코프의 이해가 쉽고, 호이스팅과 같은 예기치 않은 동작을 방지할 수 있기 때문입니다. 상수로 선언할 값은 `const`를 사용하여 변하지 않음을 명시하는 것이 좋습니다.

## Promise와 async/await의 차이점은 무엇인가요?

Promise와 async/await는 JavaScript에서 비동기 작업을 다루는 데 사용되는 기술입니다. 그러나 두 가지 접근 방식에는 몇 가지 차이가 있습니다.

1. **구문**:

   - **Promise**: Promise는 비동기 작업의 결과를 나타내는 객체입니다. Promise를 사용할 때는 `then()`과 `catch()` 메서드를 사용하여 성공적인 결과나 실패한 경우의 처리를 정의합니다.
   - **async/await**: async 함수 내에서 await 키워드를 사용하여 비동기 작업의 완료를 기다릴 수 있습니다. async 함수는 항상 Promise를 반환하며, 해당 Promise가 해결될 때까지 기다린 후 결과를 반환합니다.

2. **가독성**:

   - **Promise**: 비동기 작업의 체이닝을 위해 `.then()`을 연속적으로 사용해야 하므로 가독성이 떨어질 수 있습니다. 특히 여러 개의 비동기 작업을 연결할 때는 콜백 지옥(callback hell)이 발생할 수 있습니다.
   - **async/await**: async/await는 비동기 코드를 동기적으로 작성할 수 있도록 해줍니다. 이로 인해 코드가 더 읽기 쉽고 이해하기 쉬워지며, 콜백 지옥을 피할 수 있습니다.

3. **오류 처리**:

   - **Promise**: Promise에서 오류 처리는 `catch()` 메서드를 사용하여 처리합니다.
   - **async/await**: async/await는 `try-catch` 블록을 사용하여 오류를 처리합니다. 이로 인해 오류 처리가 보다 명확하고 구조화되며, 예외를 쉽게 처리할 수 있습니다.

4. **병렬 처리**:

   - **Promise**: Promise.all()을 사용하여 여러 개의 Promise를 병렬로 처리할 수 있습니다.
   - **async/await**: async/await는 병렬 처리를 직접 지원하지 않으므로 여러 개의 비동기 작업을 병렬로 실행하려면 Promise.all()과 함께 사용해야 합니다.

일반적으로는 코드의 가독성과 유지보수를 위해 async/await를 사용하는 것이 좋습니다. 그러나 Promise는 여전히 JavaScript에서 매우 유용하고 널리 사용되는 기능이며, 특정 상황에 따라 더 적합한 경우도 있습니다.

## 이벤트 루프에 대해서 설명해주실 수 있나요?

네, 이벤트 루프(Event Loop)는 JavaScript 런타임 환경에서 비동기 작업을 처리하는 데 중요한 역할을 하는 개념입니다. 이벤트 루프는 싱글 스레드 환경에서 비동기적으로 실행되는 작업들을 관리하고 실행하는 메커니즘입니다.

JavaScript는 단일 스레드로 동작합니다. 이는 한 번에 하나의 작업만을 처리할 수 있음을 의미합니다. 하지만 비동기 작업들을 처리할 수 있도록 이벤트 루프가 도입되었습니다. 이벤트 루프는 메인 스레드에서 작업을 순차적으로 처리하면서, 비동기 작업의 완료 여부를 감시하고 필요할 때 해당 작업을 처리합니다.

이벤트 루프의 주요 구성 요소는 다음과 같습니다:

1. **Call Stack(호출 스택)**:

   - 현재 실행 중인 함수의 호출 정보를 저장하는 공간입니다. 함수가 호출되면 해당 함수의 정보가 스택에 쌓이고, 함수가 종료되면 스택에서 제거됩니다.

2. **Callback Queue(콜백 큐)**:

   - 비동기 작업의 콜백 함수가 대기하는 공간입니다. 비동기 작업이 완료되면 해당 콜백 함수가 콜백 큐에 추가됩니다.

3. **Event Loop(이벤트 루프)**:

   - 이벤트 루프는 호출 스택과 콜백 큐를 감시하면서 호출 스택이 비어있을 때 콜백 큐에서 콜백 함수를 가져와 호출 스택으로 이동시킵니다.
   - 호출 스택이 비어있지 않으면 이벤트 루프는 콜백 큐를 감시하며 호출 스택이 비어있을 때까지 대기합니다.

이렇게 이벤트 루프를 통해 JavaScript는 비동기 작업을 효율적으로 처리하고, 동시에 싱글 스레드로 동작하는 특성을 유지합니다. 이벤트 루프를 이해하면 JavaScript에서 비동기 코드를 작성하고 이해하는 데 도움이 됩니다.

## 이벤트 버블링과 이벤트 캡쳐링에 대해서 설명해보시겠어요?

캡처링(Event Capturing)은 이벤트가 상위 요소에서 하위 요소로 전파되는 것이며, 버블링(Event Bubbling)은 이벤트가 하위 요소에서 상위 요소로 전파되는 것입니다.

따라서 캡처링은 상위 요소에서 하위 요소로, 버블링은 하위 요소에서 상위 요소로 이벤트가 전파됩니다.

이벤트 캡처링과 이벤트 버블링은 둘 다 이벤트가 DOM 트리를 따라 전파되는 방식을 설명하지만, 발생하는 방향에 차이가 있습니다. 기본적으로는 이벤트 버블링이 사용되지만, 이벤트 캡처링을 활용하여 이벤트 핸들러를 부모 요소에서부터 미리 처리할 수도 있습니다. 이러한 이벤트 전파 모델을 이해하면 이벤트 처리 및 이벤트 위임 등을 더욱 효과적으로 구현할 수 있습니다.

## 이벤트 버블링과 이벤트 캡쳐링이 둘다 있을 때 어떤 것이 적용되나요?

이벤트 버블링과 이벤트 캡처링이 둘 다 적용되는 경우에는 브라우저에서는 일반적으로 이벤트 캡처링이 먼저 발생한 후 이벤트 버블링이 발생합니다. 이것은 이벤트 흐름이 이벤트 캡처링 단계로 시작하여 이벤트 버블링 단계로 이어지는 것을 의미합니다.

따라서, 이벤트가 발생한 요소에서 시작하여 가장 먼 조상 요소까지 이벤트 캡처링 단계를 거쳐 올라가고, 이후에 다시 발생한 요소로부터 시작하여 가장 먼 조상 요소까지 이벤트 버블링 단계를 거쳐 내려오게 됩니다.

이것은 W3C의 이벤트 모델에 따른 동작 방식이며, 대부분의 브라우저가 이를 따르고 있습니다. 그러나 일부 브라우저는 이벤트 캡처링과 이벤트 버블링을 제대로 지원하지 않을 수도 있습니다. 이 경우, 이벤트 핸들러가 등록된 순서에 따라 동작할 수 있습니다.

## 이벤트 전파와 이벤트 위임에 대해서 설명해주시겠어요?

이벤트 전파(Event Propagation)와 이벤트 위임(Event Delegation)은 JavaScript에서 이벤트 처리에 관련된 개념입니다.

1. **이벤트 전파(Event Propagation)**:

   - 이벤트 전파는 HTML 요소 간에 발생한 이벤트가 DOM 트리를 따라 전파되는 과정을 의미합니다.
   - 이벤트 전파에는 캡처링 단계, 타겟 단계, 그리고 버블링 단계가 있습니다.

2. **이벤트 위임(Event Delegation)**:

   - 이벤트 위임은 이벤트를 처리할 때, 상위 요소에 이벤트 핸들러를 등록하고 하위 요소의 이벤트를 해당 핸들러에서 처리하는 기법입니다.
   - 이벤트 위임을 사용하면 동적으로 생성되는 요소에 대해서도 이벤트를 처리할 수 있습니다.
   - 예를 들어, 리스트 요소들 각각에 이벤트 핸들러를 등록하는 대신, 리스트의 상위 요소에 하나의 이벤트 핸들러를 등록하고 클릭된 요소에 대한 처리를 구현할 수 있습니다.

이벤트 전파는 DOM 트리를 따라 이벤트가 전파되는 방식을 설명하는 개념이며, 이벤트 위임은 상위 요소에서 하위 요소의 이벤트를 처리하는 기법을 의미합니다. 이벤트 위임은 동적으로 생성되는 요소나 여러 요소에 대해 효율적으로 이벤트를 처리할 수 있도록 도와줍니다.

## event.target과 event.currentTarget의 차이점은 무엇입니까?

가정하에 아래와 같은 HTML 구조가 있다고 가정합니다:

```html
<div id="outer">
  <div id="inner">
    <button>Click me</button>
  </div>
</div>
```

그리고 이 HTML에 대한 클릭 이벤트 핸들러가 아래와 같이 설정되어 있다고 가정합니다:

```javascript
document.getElementById("outer").addEventListener("click", function (event) {
  console.log("Outer clicked!");
  console.log("event.target:", event.target);
  console.log("event.currentTarget:", event.currentTarget);
});

document.getElementById("inner").addEventListener("click", function (event) {
  console.log("Inner clicked!");
  console.log("event.target:", event.target);
  console.log("event.currentTarget:", event.currentTarget);
});
```

이제 버튼을 클릭해보겠습니다. 버튼이 클릭되면 이벤트는 버블링되며, `button` 요소에서부터 부모 요소인 `div` 요소, 마지막으로 `document`까지 버블링됩니다.

버튼을 클릭했을 때의 콘솔 출력은 다음과 같습니다:

```
Inner clicked!
event.target: <button>Click me</button>
event.currentTarget: <div id="inner">...</div>

Outer clicked!
event.target: <button>Click me</button>
event.currentTarget: <div id="outer">...</div>
```

위의 출력에서 볼 수 있듯이, `event.target`은 실제로 클릭된 요소인 버튼을 가리키고 있고, `event.currentTarget`은 이벤트 핸들러가 현재 실행 중인 요소를 가리킵니다. 내부 이벤트 핸들러에서는 `event.currentTarget`이 내부 `div#inner` 요소를 가리키고, 외부 이벤트 핸들러에서는 `event.currentTarget`이 외부 `div#outer` 요소를 가리킵니다.

## 자바스크립트의 프로토타입은 무엇인가요?

자바스크립트의 프로토타입(Prototype)은 객체 지향 프로그래밍에서 객체 간 상속을 구현하는 메커니즘입니다. 모든 JavaScript 객체는 다른 객체로부터 상속된 프로토타입을 가지고 있습니다. 프로토타입은 객체의 부모 역할을 하며, 해당 객체에서 사용할 수 있는 속성과 메서드를 제공합니다.

JavaScript에서의 프로토타입은 다음과 같은 특징을 가지고 있습니다:

1. **프로토타입 체인(Prototype Chain)**:

   - JavaScript에서 모든 객체는 프로토타입을 가지고 있습니다. 객체가 특정 속성 또는 메서드를 찾을 때 해당 객체의 프로토타입 체인을 따라 상위 프로토타입으로 이동하여 검색합니다. 이러한 프로토타입 체인을 통해 상속과 메서드의 공유가 가능해집니다.

2. **[[Prototype]] 내부 속성**:

   - 모든 JavaScript 객체는 `[[Prototype]]`이라는 내부 속성을 가지고 있습니다. 이 속성은 해당 객체의 프로토타입을 가리킵니다. 객체를 생성할 때 프로토타입은 자동으로 설정되며, `Object.getPrototypeOf()` 또는 `__proto__`를 통해 프로토타입에 접근할 수 있습니다.

3. **프로토타입 기반 상속(Prototype-based Inheritance)**:

   - JavaScript는 클래스 기반의 상속이 아닌 프로토타입 기반의 상속을 지원합니다. 새로운 객체를 생성할 때 다른 객체를 기반으로 생성하고, 이를 통해 해당 객체의 속성과 메서드를 상속받을 수 있습니다.

프로토타입은 JavaScript에서 객체 지향 프로그래밍을 구현하는 데 중요한 개념이며, 객체 간의 상속과 코드의 재사용을 가능하게 합니다. 클래스 기반의 상속과는 다르게 JavaScript의 프로토타입 기반 상속은 동적이고 유연한 객체 지향 프로그래밍을 제공합니다.

## 클래스 기반 상속과 프로토타입 기반 상속의 차이점은 무엇인가요?

클래스 기반 상속(Classical Inheritance)과 프로토타입 기반 상속(Prototype-based Inheritance)은 객체 지향 프로그래밍에서 상속을 구현하는 두 가지 접근 방식입니다. 이 두 가지 접근 방식의 주요 차이점은 다음과 같습니다:

1. **구조적인 차이**:

   - 클래스 기반 상속: 클래스 기반 언어에서는 클래스 간의 상속 관계가 명시적으로 정의됩니다. 부모 클래스와 자식 클래스가 구분되며, 자식 클래스는 부모 클래스를 확장하여 상속받은 속성과 메서드를 사용합니다.
   - 프로토타입 기반 상속: 프로토타입 기반 언어에서는 객체 간의 상속 관계가 프로토타입 체인을 통해 구현됩니다. 객체는 다른 객체를 기반으로 생성되며, 프로토타입 객체의 속성과 메서드를 상속받습니다.

2. **동적인 특성**:

   - 클래스 기반 상속: 클래스는 정적으로 정의되며, 인스턴스화된 후에는 상속 구조가 변경되지 않습니다.
   - 프로토타입 기반 상속: 프로토타입은 동적으로 변경될 수 있으며, 객체의 프로토타입을 동적으로 교체하여 상속 구조를 변경할 수 있습니다.

3. **상속 방식**:

   - 클래스 기반 상속: 부모 클래스의 속성과 메서드가 자식 클래스에 상속됩니다. 자식 클래스는 부모 클래스의 인스턴스를 확장하여 상속받은 기능을 사용합니다.
   - 프로토타입 기반 상속: 객체는 다른 객체를 프로토타입으로 가지고 있습니다. 자식 객체는 부모 객체를 기반으로 생성되며, 프로토타입 체인을 통해 부모 객체의 속성과 메서드를 상속받습니다.

4. **구현 언어**:

   - 클래스 기반 상속: 대표적으로 자바(Java), C++, C# 등의 언어에서 클래스 기반의 상속을 지원합니다.
   - 프로토타입 기반 상속: JavaScript와 같이 프로토타입 기반 언어에서는 프로토타입 체인을 통해 상속을 구현합니다.

클래스 기반 상속과 프로토타입 기반 상속은 각각의 특징에 따라 다른 상황에 적합하며, 개발자가 사용하는 언어와 해당 언어의 패러다임에 따라 선택되어야 합니다.

## ES5와 ES6의 차이점은 어떤 것이 있나요?

ES5(ECMAScript 5)와 ES6(ECMAScript 2015, 또는 ES2015) 사이의 주요 차이점은 다음과 같습니다:

1. **문법 및 기능 추가**:

   - ES6에서는 여러 문법적 향상과 새로운 기능이 추가되었습니다. 예를 들어, 화살표 함수, 클래스, 템플릿 리터럴, 비구조화 할당, let 및 const 변수 선언, 확장된 객체 리터럴 등의 기능이 추가되었습니다.

2. **화살표 함수**:

   - ES6에서 도입된 화살표 함수는 간결한 문법을 제공하며, 함수를 선언하는 데 유용합니다. 기존의 함수 표현식보다 간결하고 가독성이 높으며, 자신의 this를 바인딩하지 않고 상위 스코프의 this를 그대로 사용합니다.

3. **클래스 및 모듈**:

   - ES6에서는 클래스 문법이 도입되어 객체 지향 프로그래밍을 보다 간결하게 작성할 수 있습니다. 또한, 모듈 시스템이 추가되어 코드를 모듈화하고 재사용성을 높일 수 있습니다.

4. **let 및 const 변수 선언**:

   - ES6에서는 var 대신 let과 const 키워드를 사용하여 변수를 선언할 수 있습니다. let은 블록 범위(block scope)를 가지고 있으며 재할당이 가능한 변수를 선언할 때 사용되고, const는 상수를 선언할 때 사용되며 재할당이 불가능합니다.

5. **템플릿 리터럴**:

   - ES6에서는 백틱(backtick) 문자(`)를 사용하여 문자열을 정의하는 템플릿 리터럴이 추가되었습니다. 이를 통해 문자열 내에서 변수를 쉽게 삽입할 수 있고 여러 줄로 이루어진 문자열을 표현할 수 있습니다.

6. **확장된 객체 리터럴**:

   - ES6에서는 객체 리터럴의 기능이 확장되었습니다. 객체 리터럴 내에서 동적으로 속성 이름을 정의할 수 있고, 메서드를 간결하게 정의할 수 있습니다.

7. **비구조화 할당**:

   - ES6에서는 객체나 배열에서 필요한 값을 추출하여 변수에 할당하는 비구조화 할당(destructuring assignment) 기능이 추가되었습니다.

8. **Promise와 제너레이터**:

   - ES6에서는 비동기 프로그래밍을 위한 Promise와 제너레이터(generator)라는 새로운 기능이 도입되었습니다.

ES6는 JavaScript의 업그레이드된 버전으로, 코드의 가독성과 효율성을 높이고 개발자가 보다 효율적으로 작업할 수 있도록 여러 가지 새로운 기능을 제공합니다. ES6은 ES5의 기능을 보완하고 확장하여 모던 웹 개발에 필수적인 요소가 되었습니다.

## 클로저에 대해서 설명해주실 수 있나요?

클로저(Closure)는 함수와 함수가 선언된 어휘적 환경(Lexical Environment)의 조합입니다. 이는 함수가 선언될 때 주변 범위에 대한 참조를 유지하고 있는 것을 의미합니다. 클로저는 함수 내부에서 외부 변수를 사용할 때 발생하며, 해당 함수가 외부 범위에 접근할 수 있는 능력을 가지게 합니다.

클로저는 외부 범위의 변수를 보호하고 은닉화할 수 있는 기능을 제공합니다. 이는 함수 내부에서 외부 변수를 수정하거나 접근하는 것을 방지하여 변수의 값이 의도치 않게 변경되는 것을 막아줍니다. 또한 비동기 작업이나 콜백 함수 등에서 외부 상태를 유지하고 관리하는 데 유용하게 사용됩니다.

## falsy 값에는 어떤 것들이 있나요?

JavaScript에서 falsy 값은 조건식이나 불리언 연산에서 false로 간주되는 값들을 의미합니다. 다음은 JavaScript에서 falsy 값으로 간주되는 주요한 값들입니다:

1. **false**: 명시적으로 false 값을 가집니다.

2. **0**: 숫자 0은 falsy 값으로 간주됩니다.

3. **빈 문자열('')**: 아무런 문자를 포함하지 않는 빈 문자열은 falsy 값입니다.

4. **null**: null은 falsy 값입니다.

5. **undefined**: 변수가 할당되지 않거나 값이 없는 경우 undefined를 반환하며, 이는 falsy 값입니다.

6. **NaN(Not a Number)**: 숫자가 아닌 경우 NaN을 반환하며, 이는 falsy 값입니다.

7. **false를 제외한 모든 다른 값들**: 위에 언급된 값들 외에는 모두 truthy 값으로 간주됩니다.

이러한 falsy 값들은 주로 조건문에서 사용되어 특정 조건이 거짓일 때 특정 작업을 수행하도록 합니다. 예를 들어, if문에서 변수가 null이거나 값이 없는 경우에 특정 동작을 실행하도록 설정할 수 있습니다.
