# Javascript

## var와 let, const의 차이점은 무엇인가요?

`var`, `let`, 그리고 `const`는 JavaScript에서 변수를 선언하는 키워드입니다. 이들의 주요 차이점은 다음과 같습니다:

1. **Scope(범위)**:

   - `var`: 함수 스코프를 갖습니다. 함수 내에서 선언된 변수는 함수 내부에서만 유효합니다.
   - `let`과 `const`: 블록 스코프를 갖습니다. 블록 내에서 선언된 변수는 해당 블록 내부에서만 유효합니다. 블록은 중괄호 `{}`로 정의되는 영역입니다.

2. **Hoisting(호이스팅)**:

   - `var`: 선언이 함수나 전역 스코프의 맨 위로 끌어올려집니다. 그러므로 변수가 선언되기 이전에 참조해도 에러가 발생하지 않습니다. 하지만 초기화는 호이스팅되지 않습니다.
   - `let`과 `const`: 호이스팅은 발생하지만, TDZ(Temporal Dead Zone)라는 구역에서 변수에 접근하려고 할 때 초기화 전에는 에러가 발생합니다.

3. **재할당 가능 여부**:

   - `var`와 `let`: 재할당이 가능합니다.
   - `const`: 한 번 할당하면 재할당할 수 없습니다. 상수로 취급되어 재할당하려고 하면 에러가 발생합니다. 하지만 const로 선언된 객체나 배열의 속성은 변경할 수 있습니다.

4. **전역 객체와의 관계**:

   - `var`로 선언한 변수는 전역 객체의 프로퍼티가 됩니다. 즉, 브라우저 환경에서는 `window` 객체의 프로퍼티가 됩니다.
   - `let`과 `const`로 선언한 변수는 전역 객체의 프로퍼티가 되지 않습니다. 이는 변수가 선언된 블록 내에서만 유효하기 때문입니다.

일반적으로는 `let`과 `const`를 사용하여 변수를 선언하는 것이 권장됩니다. 이는 스코프의 이해가 쉽고, 호이스팅과 같은 예기치 않은 동작을 방지할 수 있기 때문입니다. 상수로 선언할 값은 `const`를 사용하여 변하지 않음을 명시하는 것이 좋습니다.

## Promise와 async/await의 차이점은 무엇인가요?

Promise와 async/await는 JavaScript에서 비동기 작업을 다루는 데 사용되는 기술입니다. 그러나 두 가지 접근 방식에는 몇 가지 차이가 있습니다.

1. **구문**:

   - **Promise**: Promise는 비동기 작업의 결과를 나타내는 객체입니다. Promise를 사용할 때는 `then()`과 `catch()` 메서드를 사용하여 성공적인 결과나 실패한 경우의 처리를 정의합니다.
   - **async/await**: async 함수 내에서 await 키워드를 사용하여 비동기 작업의 완료를 기다릴 수 있습니다. async 함수는 항상 Promise를 반환하며, 해당 Promise가 해결될 때까지 기다린 후 결과를 반환합니다.

2. **가독성**:

   - **Promise**: 비동기 작업의 체이닝을 위해 `.then()`을 연속적으로 사용해야 하므로 가독성이 떨어질 수 있습니다. 특히 여러 개의 비동기 작업을 연결할 때는 콜백 지옥(callback hell)이 발생할 수 있습니다.
   - **async/await**: async/await는 비동기 코드를 동기적으로 작성할 수 있도록 해줍니다. 이로 인해 코드가 더 읽기 쉽고 이해하기 쉬워지며, 콜백 지옥을 피할 수 있습니다.

3. **오류 처리**:

   - **Promise**: Promise에서 오류 처리는 `catch()` 메서드를 사용하여 처리합니다.
   - **async/await**: async/await는 `try-catch` 블록을 사용하여 오류를 처리합니다. 이로 인해 오류 처리가 보다 명확하고 구조화되며, 예외를 쉽게 처리할 수 있습니다.

4. **병렬 처리**:

   - **Promise**: Promise.all()을 사용하여 여러 개의 Promise를 병렬로 처리할 수 있습니다.
   - **async/await**: async/await는 병렬 처리를 직접 지원하지 않으므로 여러 개의 비동기 작업을 병렬로 실행하려면 Promise.all()과 함께 사용해야 합니다.

일반적으로는 코드의 가독성과 유지보수를 위해 async/await를 사용하는 것이 좋습니다. 그러나 Promise는 여전히 JavaScript에서 매우 유용하고 널리 사용되는 기능이며, 특정 상황에 따라 더 적합한 경우도 있습니다.

## 이벤트 루프에 대해서 설명해주실 수 있나요?

네, 이벤트 루프(Event Loop)는 JavaScript 런타임 환경에서 비동기 작업을 처리하는 데 중요한 역할을 하는 개념입니다. 이벤트 루프는 싱글 스레드 환경에서 비동기적으로 실행되는 작업들을 관리하고 실행하는 메커니즘입니다.

JavaScript는 단일 스레드로 동작합니다. 이는 한 번에 하나의 작업만을 처리할 수 있음을 의미합니다. 하지만 비동기 작업들을 처리할 수 있도록 이벤트 루프가 도입되었습니다. 이벤트 루프는 메인 스레드에서 작업을 순차적으로 처리하면서, 비동기 작업의 완료 여부를 감시하고 필요할 때 해당 작업을 처리합니다.

이벤트 루프의 주요 구성 요소는 다음과 같습니다:

1. **Call Stack(호출 스택)**:

   - 현재 실행 중인 함수의 호출 정보를 저장하는 공간입니다. 함수가 호출되면 해당 함수의 정보가 스택에 쌓이고, 함수가 종료되면 스택에서 제거됩니다.

2. **Callback Queue(콜백 큐)**:

   - 비동기 작업의 콜백 함수가 대기하는 공간입니다. 비동기 작업이 완료되면 해당 콜백 함수가 콜백 큐에 추가됩니다.

3. **Event Loop(이벤트 루프)**:

   - 이벤트 루프는 호출 스택과 콜백 큐를 감시하면서 호출 스택이 비어있을 때 콜백 큐에서 콜백 함수를 가져와 호출 스택으로 이동시킵니다.
   - 호출 스택이 비어있지 않으면 이벤트 루프는 콜백 큐를 감시하며 호출 스택이 비어있을 때까지 대기합니다.

이렇게 이벤트 루프를 통해 JavaScript는 비동기 작업을 효율적으로 처리하고, 동시에 싱글 스레드로 동작하는 특성을 유지합니다. 이벤트 루프를 이해하면 JavaScript에서 비동기 코드를 작성하고 이해하는 데 도움이 됩니다.

## 이벤트 버블링과 이벤트 캡쳐링에 대해서 설명해보시겠어요?

캡처링(Event Capturing)은 이벤트가 상위 요소에서 하위 요소로 전파되는 것이며, 버블링(Event Bubbling)은 이벤트가 하위 요소에서 상위 요소로 전파되는 것입니다.

따라서 캡처링은 상위 요소에서 하위 요소로, 버블링은 하위 요소에서 상위 요소로 이벤트가 전파됩니다.

이벤트 캡처링과 이벤트 버블링은 둘 다 이벤트가 DOM 트리를 따라 전파되는 방식을 설명하지만, 발생하는 방향에 차이가 있습니다. 기본적으로는 이벤트 버블링이 사용되지만, 이벤트 캡처링을 활용하여 이벤트 핸들러를 부모 요소에서부터 미리 처리할 수도 있습니다. 이러한 이벤트 전파 모델을 이해하면 이벤트 처리 및 이벤트 위임 등을 더욱 효과적으로 구현할 수 있습니다.

## 이벤트 버블링과 이벤트 캡쳐링이 둘다 있을 때 어떤 것이 적용되나요?

이벤트 버블링과 이벤트 캡처링이 둘 다 적용되는 경우에는 브라우저에서는 일반적으로 이벤트 캡처링이 먼저 발생한 후 이벤트 버블링이 발생합니다. 이것은 이벤트 흐름이 이벤트 캡처링 단계로 시작하여 이벤트 버블링 단계로 이어지는 것을 의미합니다.

따라서, 이벤트가 발생한 요소에서 시작하여 가장 먼 조상 요소까지 이벤트 캡처링 단계를 거쳐 올라가고, 이후에 다시 발생한 요소로부터 시작하여 가장 먼 조상 요소까지 이벤트 버블링 단계를 거쳐 내려오게 됩니다.

이것은 W3C의 이벤트 모델에 따른 동작 방식이며, 대부분의 브라우저가 이를 따르고 있습니다. 그러나 일부 브라우저는 이벤트 캡처링과 이벤트 버블링을 제대로 지원하지 않을 수도 있습니다. 이 경우, 이벤트 핸들러가 등록된 순서에 따라 동작할 수 있습니다.

## 이벤트 전파와 이벤트 위임에 대해서 설명해주시겠어요?

이벤트 전파(Event Propagation)와 이벤트 위임(Event Delegation)은 JavaScript에서 이벤트 처리에 관련된 개념입니다.

1. **이벤트 전파(Event Propagation)**:

   - 이벤트 전파는 HTML 요소 간에 발생한 이벤트가 DOM 트리를 따라 전파되는 과정을 의미합니다.
   - 이벤트 전파에는 캡처링 단계, 타겟 단계, 그리고 버블링 단계가 있습니다.

2. **이벤트 위임(Event Delegation)**:

   - 이벤트 위임은 이벤트를 처리할 때, 상위 요소에 이벤트 핸들러를 등록하고 하위 요소의 이벤트를 해당 핸들러에서 처리하는 기법입니다.
   - 이벤트 위임을 사용하면 동적으로 생성되는 요소에 대해서도 이벤트를 처리할 수 있습니다.
   - 예를 들어, 리스트 요소들 각각에 이벤트 핸들러를 등록하는 대신, 리스트의 상위 요소에 하나의 이벤트 핸들러를 등록하고 클릭된 요소에 대한 처리를 구현할 수 있습니다.

이벤트 전파는 DOM 트리를 따라 이벤트가 전파되는 방식을 설명하는 개념이며, 이벤트 위임은 상위 요소에서 하위 요소의 이벤트를 처리하는 기법을 의미합니다. 이벤트 위임은 동적으로 생성되는 요소나 여러 요소에 대해 효율적으로 이벤트를 처리할 수 있도록 도와줍니다.

## event.target과 event.currentTarget의 차이점은 무엇입니까?

가정하에 아래와 같은 HTML 구조가 있다고 가정합니다:

```html
<div id="outer">
  <div id="inner">
    <button>Click me</button>
  </div>
</div>
```

그리고 이 HTML에 대한 클릭 이벤트 핸들러가 아래와 같이 설정되어 있다고 가정합니다:

```javascript
document.getElementById("outer").addEventListener("click", function (event) {
  console.log("Outer clicked!");
  console.log("event.target:", event.target);
  console.log("event.currentTarget:", event.currentTarget);
});

document.getElementById("inner").addEventListener("click", function (event) {
  console.log("Inner clicked!");
  console.log("event.target:", event.target);
  console.log("event.currentTarget:", event.currentTarget);
});
```

이제 버튼을 클릭해보겠습니다. 버튼이 클릭되면 이벤트는 버블링되며, `button` 요소에서부터 부모 요소인 `div` 요소, 마지막으로 `document`까지 버블링됩니다.

버튼을 클릭했을 때의 콘솔 출력은 다음과 같습니다:

```
Inner clicked!
event.target: <button>Click me</button>
event.currentTarget: <div id="inner">...</div>

Outer clicked!
event.target: <button>Click me</button>
event.currentTarget: <div id="outer">...</div>
```

위의 출력에서 볼 수 있듯이, `event.target`은 실제로 클릭된 요소인 버튼을 가리키고 있고, `event.currentTarget`은 이벤트 핸들러가 현재 실행 중인 요소를 가리킵니다. 내부 이벤트 핸들러에서는 `event.currentTarget`이 내부 `div#inner` 요소를 가리키고, 외부 이벤트 핸들러에서는 `event.currentTarget`이 외부 `div#outer` 요소를 가리킵니다.
