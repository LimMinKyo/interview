# 프론트엔드

## HTML과 DOM의 차이점이 무엇인가요?

HTML과 DOM은 웹 개발에서 중요한 개념이지만 서로 다른 것입니다.

1. **HTML (HyperText Markup Language)**:

   - HTML은 웹 페이지의 구조와 콘텐츠를 정의하는 마크업 언어입니다.
   - HTML은 웹 브라우저에게 어떻게 콘텐츠를 표시해야 하는지를 알려주는 역할을 합니다.
   - 개발자는 HTML을 사용하여 텍스트, 이미지, 링크, 테이블 등을 포함하는 웹 페이지의 레이아웃을 정의합니다.
   - HTML은 정적인 마크업 언어로, 사용자의 상호 작용이나 동적인 변경에 대응하지 않습니다.

2. **DOM (Document Object Model)**:

   - DOM은 웹 페이지의 구조를 프로그래밍적으로 접근하고 조작할 수 있는 인터페이스입니다.
   - 웹 브라우저는 HTML 문서를 로드한 후, 해당 문서의 구조를 메모리에 트리 형태로 표현한 DOM 트리를 생성합니다.
   - DOM은 HTML 문서의 요소(element), 속성(attribute), 텍스트 등을 객체로 표현합니다. 이러한 객체들은 JavaScript를 사용하여 접근하고 조작할 수 있습니다.
   - JavaScript를 사용하여 DOM을 조작함으로써 동적인 웹 페이지를 생성하거나 사용자 상호 작용에 대응할 수 있습니다.

요약하면, HTML은 웹 페이지의 정적인 구조와 콘텐츠를 정의하는 마크업 언어이며, DOM은 이러한 HTML 문서를 프로그래밍적으로 접근하고 조작할 수 있는 인터페이스입니다. HTML은 웹 페이지를 설계하는 데 사용되고, DOM은 JavaScript를 사용하여 HTML 문서를 동적으로 조작하는 데 사용됩니다.

## CSS 우선순위에 대해서 설명해주실 수 있나요?

CSS에서 스타일이 적용되는 우선순위는 다음과 같은 규칙에 따라 결정됩니다. 이러한 우선순위는 스타일 규칙이 충돌할 때 어떤 스타일이 우선하여 적용되는지를 결정합니다. 아래에서는 우선순위를 결정하는 규칙들을 순서대로 설명하겠습니다.

1. **!important 규칙**:

   - `!important` 키워드가 스타일 속성 뒤에 붙어 있으면 해당 속성은 다른 모든 스타일 규칙보다 우선시됩니다.

2. **인라인 스타일(Inline Style)**:

   - HTML 요소의 `style` 속성을 통해 직접 적용된 스타일은 다른 모든 스타일 규칙보다 우선시됩니다.

3. **ID 선택자(ID Selectors)**:

   - ID 선택자에 의해 지정된 스타일은 클래스 선택자나 태그 선택자에 의해 지정된 스타일보다 우선시됩니다.

4. **클래스 선택자(Class Selectors), 속성 선택자(Attribute Selectors), 가상 클래스 선택자(Pseudo-class Selectors)**:

   - 클래스 선택자, 속성 선택자, 가상 클래스 선택자에 의해 지정된 스타일은 태그 선택자에 의해 지정된 스타일보다 우선시됩니다.

5. **태그 선택자(Tag Selectors)**:

   - 태그 선택자에 의해 지정된 스타일은 기본적으로 가장 낮은 우선순위를 갖습니다.

6. **상위 우선순위 규칙**:

   - 위에서 설명한 규칙들은 우선순위가 동일할 경우에만 적용됩니다. 그렇지 않은 경우에는 다음과 같은 우선순위를 갖습니다.
     1. 소스 코드에서 더 나중에 선언된 스타일이 우선합니다.
     2. 스타일 규칙의 특이성(Specificity)이 더 높은 규칙이 우선합니다.
     3. 스타일 규칙의 선언이 더 구체적인 규칙에 의해 오버라이드되었을 경우, 해당 속성은 오버라이드된 규칙에 따라 적용됩니다.

이러한 CSS 스타일 우선순위 규칙을 이해하면 스타일 규칙 간의 충돌을 효과적으로 해결할 수 있습니다.

## 리액트 Virtual-DOM이 무엇인가요?

리액트(Virtual-DOM)은 리액트에서 사용되는 핵심 개념 중 하나입니다. Virtual-DOM은 가상 DOM의 줄임말로, 실제 DOM의 가벼운 복제품이라고 생각할 수 있습니다.

일반적으로 웹 애플리케이션에서는 DOM(Document Object Model)을 사용하여 웹 페이지의 구조를 표현합니다. DOM은 웹 페이지의 요소를 나타내는 트리 구조입니다. 이 DOM을 직접 조작하면서 UI를 업데이트하는 것은 성능에 부담이 될 수 있습니다. 예를 들어, 많은 요소를 한 번에 조작하면 렌더링이 지연되고 반응성이 떨어질 수 있습니다.

리액트는 이러한 문제를 해결하기 위해 Virtual-DOM을 도입했습니다. Virtual-DOM은 실제 DOM의 가벼운 복제품으로, 메모리 상에서 관리됩니다. 리액트는 가상 DOM을 사용하여 UI 업데이트를 수행하고, 이전 가상 DOM과 현재 가상 DOM을 비교하여 실제 DOM에만 변경된 부분을 반영합니다. 이를 통해 불필요한 DOM 조작을 최소화하고 성능을 향상시킬 수 있습니다.

가상 DOM을 사용함으로써 리액트는 UI 업데이트를 더 효율적으로 처리할 수 있으며, 개발자가 더 직관적으로 상태를 관리하고 UI를 구성할 수 있도록 도와줍니다.

## CSR과 SSR의 차이점

CSR과 SSR은 모두 웹 애플리케이션을 렌더링하는 두 가지 주요 방법입니다. 각각의 방법에 대한 차이를 설명해보겠습니다.

1. **CSR (Client-Side Rendering)**:

   - 클라이언트 측에서 페이지를 렌더링합니다.
   - 초기 HTML 및 CSS 파일을 받은 후에 JavaScript 파일을 로드하고 실행하여 동적으로 콘텐츠를 렌더링합니다.
   - 서버로부터 받은 빈 페이지를 렌더링하고, 그 이후에 클라이언트에서 JavaScript를 사용하여 데이터를 요청하고 페이지를 업데이트합니다.
   - 주로 React, Angular, Vue.js 등의 프론트엔드 프레임워크나 라이브러리를 사용하여 구현됩니다.
   - 장점: 초기 로딩 속도는 느리나 한 번 로드된 이후에는 페이지 간 전환이 빠르다. 애플리케이션의 인터랙티브한 요소들을 빠르게 제공할 수 있습니다.
   - 단점: 검색 엔진 최적화(SEO)에 취약하며, 초기 로딩 속도가 느릴 수 있습니다.

2. **SSR (Server-Side Rendering)**:

   - 서버 측에서 페이지를 렌더링합니다.
   - 클라이언트로부터 요청이 오면 서버에서 HTML을 생성하고 초기 데이터를 포함하여 응답합니다.
   - 주로 서버 측 프레임워크나 라이브러리를 사용하여 구현됩니다. (예: Next.js, Nuxt.js)
   - 장점: 검색 엔진 최적화(SEO)가 용이하며 초기 로딩 속도가 빠릅니다.
   - 단점: 서버 부하가 증가할 수 있으며, 클라이언트 측에서의 추가 로직이 필요할 수 있습니다.

요약하면, CSR은 클라이언트에서 페이지를 렌더링하고, SSR은 서버에서 페이지를 렌더링합니다. 각각의 방법은 장단점이 있으며, 프로젝트의 요구 사항과 성능 등을 고려하여 선택해야 합니다.

## 리액트를 보고 선언적이라고 하는데 선언적인 이유가 무엇일까요?

리액트를 선언적(Declarative)이라고 하는 이유는 다음과 같습니다:

1. **UI 설계 간결성**: 리액트에서는 UI를 구성할 때 JSX 문법을 사용하여 컴포넌트를 선언합니다. JSX는 JavaScript의 확장 문법으로, UI를 더 간결하고 가독성 있게 작성할 수 있도록 도와줍니다. 이를 통해 개발자는 UI를 설계할 때 필요한 세부 사항에 집중할 수 있습니다.

2. **상태 관리 추상화**: 리액트에서는 컴포넌트의 상태(state)와 생명주기(lifecycle)를 관리할 수 있는 추상화된 인터페이스를 제공합니다. 이를 통해 개발자는 상태를 직접 관리하는 것이 아니라 선언적으로 상태를 정의하고 변경할 수 있습니다.

3. **컴포넌트 기반 접근**: 리액트는 컴포넌트 기반 접근을 통해 UI를 선언적으로 구성합니다. 각각의 컴포넌트는 독립적이며 재사용 가능하며, 부모 컴포넌트에서 자식 컴포넌트로 props를 통해 데이터를 전달하고 상태를 관리합니다. 이를 통해 코드를 더 간결하고 유지보수하기 쉽게 작성할 수 있습니다.

4. **DOM 추상화**: 리액트는 Virtual DOM을 사용하여 실제 DOM을 추상화합니다. 개발자는 실제 DOM 조작에 직접 관여하지 않고, 상태의 변화에 따라 리액트가 Virtual DOM을 업데이트하고 이를 효율적으로 실제 DOM에 반영합니다.

이러한 특성들로 인해 리액트는 UI를 선언적으로 설계하고 관리할 수 있게 됩니다. 코드의 가독성과 유지보수성을 높이며, 개발자는 상태나 DOM 조작에 대한 세부 사항을 신경 쓰지 않고도 직관적으로 UI를 개발할 수 있습니다.

## SPA란 무엇인가요?

SPA(싱글 페이지 애플리케이션)는 웹 애플리케이션의 디자인 패턴 중 하나로, 단일 HTML 페이지를 사용하여 애플리케이션을 구축하는 방법입니다. SPA는 전통적인 다중 페이지 애플리케이션과는 다르게, 애플리케이션을 로드할 때 초기에 필요한 HTML, CSS 및 JavaScript를 한 번만 로드하고, 이후에는 필요한 데이터와 UI를 동적으로 로드하여 페이지 전환 없이 사용자 경험을 제공합니다.

SPA의 특징은 다음과 같습니다:

1. **단일 페이지 로딩**: SPA는 처음 페이지 로딩 후에는 서버로부터 새로운 페이지를 요청하지 않고, 동적으로 콘텐츠를 로드하여 페이지 전환 없이 사용자 경험을 제공합니다.

2. **동적 콘텐츠 로딩**: SPA는 Ajax나 Fetch API를 사용하여 필요한 데이터를 서버로부터 비동기적으로 로드하고, JavaScript를 사용하여 동적으로 UI를 업데이트합니다.

3. **라우팅**: SPA는 클라이언트 측 라우팅을 사용하여 사용자가 URL을 변경할 때 해당하는 컴포넌트만 업데이트합니다. 이를 통해 브라우저의 뒤로가기나 앞으로 가기 버튼을 사용할 때 페이지를 새로고침하지 않고 애플리케이션의 이전 상태로 이동할 수 있습니다.

4. **반응형 디자인**: SPA는 다양한 디바이스에서 일관된 사용자 경험을 제공하기 위해 반응형 디자인을 채택합니다.

SPA의 장점은 사용자 경험의 향상과 서버의 부하 감소, 개발 및 유지 보수의 용이성 등이 있습니다. 하지만 초기 로딩 시간이 길어질 수 있고, 검색 엔진 최적화(SEO)가 어려울 수 있으며, 메모리 누수와 같은 문제가 발생할 수 있습니다. 이러한 단점을 극복하기 위해 코드 스플리팅, 서버 사이드 렌더링(SSR), 프리렌더링 등의 기술을 사용할 수 있습니다.

## SPA의 단점

SPA의 단점은 앱의 규모가 커지면 자바스크립트 파일이 너무 커진다는 것입니다. 페이지 로딩 시 사용자가 실제로 방문하지 않을 수도 있는 페이지의 스크립트도 불러오기 때문이죠. 하지만 후에 배울 코드 스플리팅(code splitting)을 사용하면 라우트별로 파일들을 나누어서 트래픽과 로딩 속도를 개선할 수 있습니다.

리액트 라우터처럼 브라우저에서 자바스크립트를 사용하여 라우팅을 관리하는 것은 자바스크립트를 실행하지 않는 일반 크롤러에서는 페이지의 정보를 제대로 수집해 가지 못한다는 잠재적인 단점이 따릅니다. 그렇기 때문에 구글, 네이버, 다음과 같은 검색 엔진의 검색 결과에 페이지가 잘 나타나지 않을 수도 있습니다. 또한, 자바스크립트가 실행될 때까지 페이지가 비어 있기 때문에 자바스크립트 파일이 로딩되어 실행되는 짧은 시간 동안 흰 페이지가 나타날 수 있다는 단점도 있습니다. 하지만 이런 문제점들은 다행히 나중에 배우게 될 서버 사이드 렌더링(server-side-rendering)을 통해 모두 해결할 수 있습니다.

## Next.js에서 사전 렌더링을 위해 사용해 본 함수가 있나요?

`getStaticProps`

- 빌드시 고정되는 값으로 빌드 이후에는 수정이 불가능합니다
- data를 빌드 시에 미리 땡겨와 정적으로(static 하게) 제공합니다
- 매 유저의 요청마다 fetch할 필요가 없는 데이터를 가진 페이지를 렌더링할 때 유리합니다
- 유저에 구애받지 않고 퍼블릭하게 캐시할 수 있는 데이터
- SEO 등의 이슈로 인해 빠르게 미리 렌더링해야만 하는 페이지

`getStaticPath`

- 동적 라우팅 + getStaticProps를 원할 때 사용
- 정의하지 않은 하위 경로는 접근해도 화면이 뜨지 않는다 (error 페이지로 라우팅)
- 동적 라우팅 시, 라우팅되는 경우의 수를 하나하나 넣어야 합니다

`getServerSideProps`

- 빌드와 상관없이, 매 페이지 요청마다 데이터를 서버로부터 가져옵니다

## LCP가 뭔가요?

LCP(Large Contentful Paint)는 웹 페이지에서 가장 큰 콘텐츠 요소를 로드하고 사용자가 볼 수 있는 데 걸리는 시간을 측정하는 성능 지표입니다.

이것은 웹 페이지의 로딩 속도에 대한 사용자의 인식을 반영하고 웹 페이지에 대한 사용자의 참여에 영향을 미칠 수 있기 때문에 중요한 지표입니다.

LCP를 개선하기 위해 lazy load, 이미지 크기 및 형식 최적화, CDN(콘텐츠 전송 네트워크) 등의 기술을 사용하여 이미지 및 비디오와 같은 대용량 콘텐츠 요소의 로드를 최적화할 수 있습니다. 또한 HTML, CSS 및 JavaScript 파일의 크기를 줄이고 서버에 대한 요청 수를 최소화하여 웹 페이지의 전체 로드를 최적화할 수 있습니다.

Chrome DevTools의 Lighthouse 검사 또는 WebPageTest와 같은 도구를 사용하여 웹 페이지의 LCP를 측정할 수 있습니다.

## FCP가 뭔가요?

FCP(First Contentful Paint)는 브라우저가 웹 페이지의 첫 번째 콘텐츠 요소를 렌더링하는 데 걸리는 시간을 측정하는 성능 지표입니다. 이 내용 요소는 텍스트, 이미지 또는 사용자가 볼 수 있는 다른 유형의 내용일 수 있습니다.

FCP는 웹 페이지의 로딩 속도에 대한 사용자의 인식을 반영하고 웹 페이지에 대한 사용자의 참여에 영향을 미칠 수 있기 때문에 중요한 지표입니다.

FCP를 개선하기 위해 HTML, CSS 및 JavaScript 파일의 크기를 줄이고 서버에 대한 요청 수를 최소화하여 웹 페이지 로드를 최적화할 수 있습니다. 또한 로드 프로세스에서 우선 순위를 지정하여 위의 내용과 같은 중요한 리소스의 로드를 최적화할 수 있습니다.

## 브라우저 렌더링에 대해서 설명해 주실 수 있나요?

브라우저 렌더링은 웹 페이지를 사용자에게 시각적으로 표시하는 과정을 의미합니다. 이 과정은 다음과 같은 단계로 이루어집니다:

1. **HTML 파싱(Parsing)**:

   - 브라우저는 서버로부터 받은 HTML 문서를 파싱하여 DOM(Document Object Model)을 생성합니다.
   - HTML 파서는 문서를 시작 태그부터 끝 태그까지 읽어가며 태그와 요소를 이해하고 DOM 트리를 구성합니다.

2. **CSS 파싱(Parsing)**:

   - 브라우저는 CSS 스타일시트를 파싱하여 CSS 객체 모델(CSS Object Model)을 생성합니다.
   - CSS 파서는 각각의 스타일 규칙을 해석하고, 각 요소에 적용될 스타일을 계산합니다.

3. **렌더 트리(Render Tree) 구축**:

   - DOM 트리와 CSS 객체 모델을 결합하여 렌더 트리를 구축합니다.
   - 렌더 트리는 화면에 표시되는 요소와 스타일 정보를 담고 있습니다. 하지만 보이지 않는 요소(예: `display: none`)는 제외됩니다.

4. **레이아웃(Layout)**:

   - 렌더 트리를 기반으로 각 요소의 위치와 크기를 계산합니다.
   - 이 단계에서는 각 요소의 위치와 크기, 그리고 각 요소의 상대적인 배치에 대한 정보를 결정합니다.

5. **페인트(Paint)**:

   - 브라우저는 레이아웃 정보를 기반으로 실제 화면에 픽셀을 그립니다.
   - 각 요소의 스타일 속성에 따라 색상, 텍스트, 이미지 등이 화면에 페인팅됩니다.

6. **컴포지팅(Compositing)**:

   - 브라우저는 여러 요소가 겹쳐져 있을 때 이를 적절히 합성하여 최종 화면을 구성합니다.
   - 이 과정에서 각 요소의 투명도, 변형(예: 회전, 스케일링), 필터(예: 그림자) 등이 적용됩니다.

브라우저 렌더링은 이러한 단계를 통해 HTML, CSS, JavaScript로 구성된 웹 페이지를 화면에 표시하는 과정을 말합니다. 이 과정은 사용자가 웹 페이지를 요청하고 브라우저가 해당 페이지를 렌더링하여 화면에 표시할 때마다 반복됩니다.

## CORS에 대해서 설명해주세요.

CORS(Cross-Origin Resource Sharing)는 웹 애플리케이션에서 다른 출처(Origin)의 리소스에 접근할 때 발생하는 보안 정책입니다. 웹 브라우저는 보안상의 이유로 스크립트에서 다른 출처의 리소스에 접근하는 것을 제한합니다. 이것이 CORS 정책이 필요한 이유입니다.

일반적으로, 브라우저에서는 동일 출처(Same Origin) 정책이 적용됩니다. 이는 스크립트가 해당 스크립트가 포함된 페이지와 동일한 출처에서만 리소스에 접근할 수 있음을 의미합니다. 출처란 프로토콜(https://), 호스트(www.example.com), 포트(443)의 조합을 의미합니다.

CORS 정책을 통해 브라우저가 다른 출처의 리소스에 접근하는 것을 허용할 수 있습니다. 이를 위해 서버는 요청에 대한 응답 헤더에 특정 정보를 포함시켜야 합니다. 이 헤더는 Access-Control-Allow-Origin이라는 이름으로, 허용된 출처를 나타내는 값이 포함됩니다.

간단한 CORS 요청은 브라우저가 서버로 요청을 보내기 전에 먼저 사전 요청(preflight request)을 보냅니다. 이 사전 요청은 실제 요청을 보내기 전에 서버가 요청을 수락할 수 있는지 확인하기 위해 보내는 것입니다. 서버는 이 사전 요청에 대한 응답으로 Access-Control-Allow-Origin 헤더를 포함하여 허용된 출처를 알려줍니다.

요약하자면, CORS는 브라우저에서 다른 출처의 리소스에 접근하는 것을 제한하는 보안 정책이며, 서버가 특정 출처에 대한 접근을 허용하기 위해 특정 헤더를 포함시켜야 합니다.

## CORS가 있는 이유가 무엇인가요?

CORS(Cross-Origin Resource Sharing)가 있는 주된 이유는 보안과 개인정보 보호를 강화하기 위함입니다. 웹 애플리케이션에서 다른 출처의 리소스에 접근하는 것은 보안상의 위험이 될 수 있습니다. CORS 정책은 이러한 위험을 완화하기 위해 다음과 같은 이유로 도입되었습니다:

1. **Cross-Site Request Forgery (CSRF) 방지**: 악의적인 웹사이트가 사용자의 브라우저를 이용하여 다른 웹사이트에 요청을 보내는 것을 방지하기 위해 사용됩니다. 만약 모든 사이트에서 다른 사이트의 데이터에 자유롭게 접근할 수 있다면, 이러한 공격이 더 쉽게 이뤄질 수 있습니다.

2. **Cross-Site Scripting (XSS) 방지**: XSS 공격에서는 악의적인 스크립트가 다른 웹사이트의 콘텐츠에 액세스하여 사용자 정보를 도용하거나 쿠키를 훔치는 등의 악의적인 행위를 수행할 수 있습니다. CORS 정책을 통해 다른 출처에서의 스크립트 실행을 제한함으로써 XSS 공격을 방지할 수 있습니다.

3. **개인정보 보호**: 사용자의 개인정보와 민감한 데이터를 다른 출처의 웹사이트와 공유하는 것은 보안상 위험을 초래할 수 있습니다. CORS를 통해 특정 출처에서만 데이터 접근을 허용함으로써 개인정보 보호를 강화할 수 있습니다.

4. **보안 강화**: 서로 다른 출처 간의 통신을 제어함으로써 웹 애플리케이션의 보안을 강화할 수 있습니다. 브라우저는 CORS 정책을 준수하며, 이를 통해 사용자의 보안과 안전을 보호합니다.

이러한 이유들로 인해 CORS는 웹 보안의 중요한 요소로 간주되며, 모든 현대적인 웹 브라우저에서 지원되고 있습니다.

## CORS 오류는 어떻게 해결해야하나요?

CORS(Cross-Origin Resource Sharing) 오류는 주로 웹 애플리케이션에서 다른 출처의 리소스에 접근할 때 발생합니다. 이 오류를 해결하기 위해서는 다음과 같은 방법들을 시도할 수 있습니다:

1. **서버 측 CORS 설정 수정**: CORS 오류는 주로 서버에서 발생하는 문제입니다. 서버 측에서 CORS 정책을 수정하여 특정 출처에서의 요청을 허용하도록 CORS 헤더를 설정할 수 있습니다. 대부분의 웹 프레임워크와 서버 기술은 이러한 설정을 할 수 있는 기능을 제공합니다.

2. **Proxy 서버 사용**: 프록시 서버를 사용하여 클라이언트와 서버 간의 통신을 중계할 수 있습니다. 클라이언트는 프록시 서버와 통신하고, 프록시 서버는 다른 출처의 리소스에 접근하여 해당 리소스를 클라이언트에게 반환합니다.

어떤 방법을 선택하든, CORS 오류를 해결하기 위해서는 서버와 클라이언트 간의 통신을 잘 이해하고, 적절한 방법을 선택하여 해결해야 합니다.
